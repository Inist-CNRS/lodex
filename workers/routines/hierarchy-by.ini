; For a document selected by a URI (otherwise the first one in the stream), and with two fields as parameters, we build a hierarchy with a parent link between the two fields.
; Exemple d'URL http://localhost:3000/api/run/hierarchy-by/0yck/OEOA?maxSize=200&orderBy=value%2Fasc

prepend = delegate?file=../worker.ini
mimeType = application/json
label = hierarchy

[use]
plugin = basics
plugin = lodex
plugin = analytics

[env]
path = connectionStringURI
value = get('connectionStringURI')

[buildContext]
connectionStringURI = env('connectionStringURI')

; On garde dans l'environnement quelques paramètres
[env]
path = minValue
value = env('minValue').split('§').map(parseFloat).shift().defaultTo(0)

path = maxValue
value = env('maxValue').split('§').map(parseFloat).shift().defaultTo(1)

path = maxSize
value = env('maxSize').parseInt().defaultTo(10)

path = reverse
value = env('orderBy').split('/').get(1).replace('asc', 0).replace('desc', 1).parseInt()

path = uri
value = get('filter.uri')

path = field
value = get('field').castArray()

; On récupére les documents filtrés
; Field.0 => identifiant du champ contenant la référence au parent, c'est-à-dire l'identifiant de la ressource liée hiérarchiquement
; Field.1 => identifiant du champ contenant l'identifiant de la ressource
[LodexAggregateQuery]
stage = fix('$unwind: "$versions"')
stage = fix(`$graphLookup: { from: "publishedDataset", startWith: "$versions.${env('field.0')}", connectFromField: "versions.${env('field.0')}", connectToField: "versions.${env('field.1')}", as: "parents" }`)
stage = fix(`$lookup: { from: "publishedDataset", localField: "versions.${env('field.1')}", foreignField: "versions.${env('field.0')}", as: "enfants" }`)

[replace]
path = courant.id
value = get('uri')

path = courant.value.label
value = get(`versions.${env('field.1')}`)

path = courant.value.target
value = get('enfants').map(x =>({ id: x.uri }))

path = parents
value = get('parents').map(x =>({id: x.uri, value : { label: _.get(x,`versions.0.${env('field.1')}`)}}))

path = enfants
value = get('enfants').map(x =>({id: x.uri, value: { label: _.get(x,`versions.0.${env('field.1')}`)}}))

[exchange]
value = get('parents').reduceRight((result, current, key) => { current.value.target = [{ id: result.at(-1).id }]; return [...result, current]; }, [self.courant]).concat(self.enfants)

[ungroup]

# On regroupe les noeuds similaires
[aggregate]

[merging]


[assign]
path = value.label
value = get('value.label').uniq()

path = value.target
value = get('value.target').uniqBy('id')

# On génére le json de sortie
[LodexOutput]
indent = true
