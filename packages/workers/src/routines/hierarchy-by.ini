; For a document selected by a URI (otherwise the first one in the stream), and with two fields as parameters, we build a hierarchy with a parent link between the two fields.
; Exemple d'URL http://localhost:3000/api/run/hierarchy-by/0yck/OEOA
; Exemple d'URL http://localhost:3000/api/run/hierarchy-by/0yck/OEOA?uri=uid:/nGrpMScfa

prepend = delegate?file=../worker.ini
mimeType = application/json
label = hierarchy

[use]
plugin = basics
plugin = lodex
plugin = analytics

[env]
path = connectionStringURI
value = get('connectionStringURI')

[buildContext]
connectionStringURI = env('connectionStringURI')

; On garde dans l'environnement quelques paramètres
[env]
; On garde dans l'environnement quelques paramètres
path = minValue
value = env('minValue').split('§').map(parseFloat).shift().defaultTo(0)

path = maxValue
value = env('maxValue').split('§').map(parseFloat).shift().defaultTo(1)

path = maxSize
value = env('maxSize').parseInt().defaultTo(10)

path = reverse
value = env('orderBy').split('/').get(1).replace('asc', 0).replace('desc', 1).parseInt()

path = uri
value = get('filter.uri')

path = field
value = get('field').castArray()

; On récupére les documents filtrés
; Field.0 => identifiant du champ contenant la référence au parent, c'est-à-dire l'identifiant de la ressource liée hiérarchiquement
; Field.1 => identifiant du champ contenant l'identifiant de la ressource
[LodexAggregateQuery]
stage = fix('$unwind: "$versions"')
stage = fix(`$graphLookup: { from: "publishedDataset", startWith: "$versions.${env('field.0')}", connectFromField: "versions.${env('field.0')}", connectToField: "versions.${env('field.1')}", as: "parents", depthField: "profondeur" }`)
stage = fix(`$lookup: { from: "publishedDataset", localField: "versions.${env('field.1')}", foreignField: "versions.${env('field.0')}", as: "enfants" }`)

[assign]
path = id
value = get(`versions.${env('field.1')}`)


[replace]
path = id
value = get('id')

path = value
value = get('enfants').map(x =>[self.id,_.get(x,`versions.0.${env('field.1')}`)])

path = parentsA
value = get('parents').sortBy(['profondeur']).reverse().map(x =>_.get(x,`versions.0.${env('field.1')}`))

path = parentsB
value = get('parents').sortBy(['profondeur']).reverse().map(x =>_.get(x,`versions.0.${env('field.1')}`)).slice(1).concat(self.id)

[exchange]
value = get('parentsA').zip(self.parentsB).concat(self.value).filter(y => (y[0] && y[1] && y[0] !== y[1])).map((x) => ({value:[x[0],x[1]], id: x.join('-')}))

[ungroup]

[aggregate]
path = id

[replace]
path = source
value = get('value.0.0')

path = target
value = get('value.0.1')

# Doit thériquement correspondre aux nombres de documents dans la hiérachie, (sauf pour le noeud de tete qui n'ai pas pris en compte)
path = weight
value = get('value').size().subtract(1)

path = total
value = env('total')

path = maxSize
value = env('maxSize')

path = minValue
value = env('minValue')

path = maxValue
value = env('maxValue')


# On génére le json de sortie
[LodexOutput]
indent = true
extract = total
extract = maxSize
extract = maxValue
extract = minValue
