; For a document selected by a URI (otherwise the first one in the stream), and with two fields as parameters, we build a hierarchy with a parent link between the two fields.
; Exemple d'URL http://localhost:3000/api/run/hierarchy-by/0yck/OEOA
; Exemple d'URL http://localhost:3000/api/run/hierarchy-by/0yck/OEOA?uri=uid:/nGrpMScfa

prepend = delegate?file=../worker.ini
mimeType = application/json
label = hierarchy

[use]
plugin = basics
plugin = lodex
plugin = analytics

[env]
path = connectionStringURI
value = get('connectionStringURI')

[buildContext]
connectionStringURI = env('connectionStringURI')

[env]
; On garde dans l'environnement quelques paramètres
path = minValue
value = env('minValue').split('§').map(parseFloat).shift().defaultTo(0)

path = maxValue
value = env('maxValue').split('§').map(parseFloat).shift().defaultTo(1)

path = maxSize
value = env('maxSize').parseInt().defaultTo(10)

path = reverse
value = env('orderBy').split('/').get(1).replace('asc', 0).replace('desc', 1).parseInt()

path = uri
value = get('filter.uri')

path = field
value = get('field').castArray()

; On récupére les documents filtrés
; Field.0 => identifiant du champ contenant la référence au parent, c'est-à-dire l'identifiant de la ressource liée hiérarchiquement
; Field.1 => identifiant du champ contenant l'identifiant de la ressource
[LodexAggregateQuery]
stage = fix('$unwind: "$versions"')
; All parent nodes of the current node
stage = fix(`$graphLookup: { from: "publishedDataset", startWith: "$versions.${env('field.0')}", connectFromField: "versions.${env('field.0')}", connectToField: "versions.${env('field.1')}", as: "parents", depthField: "profondeur" }`)
; All descendant nodes of the current node

stage = fix(`$graphLookup: { from: "publishedDataset", startWith: "$versions.${env('field.1')}", connectFromField: "versions.${env('field.1')}", connectToField: "versions.${env('field.0')}", as: "enfants", depthField: "profondeur", maxDepth: 10 }`)

[replace]
path = courant.0.id
value = get('uri')
path = courant.0.value
value = get(`versions.${env('field.1')}`)
path = courant.0.target
value = get('uri')
path = courant.0.target_title
value = get(`versions.${env('field.1')}`)
path = courant.0.source_title
value = get(`versions.${env('field.0')}`)

path = enfants
value = get('enfants')\
        .sortBy(['profondeur'])\
		.map(x =>({\
			id: x.uri, \
			value:_.get(x,`versions.0.${env('field.1')}`), \
			target: x.uri, \
			target_title:_.get(x,`versions.0.${env('field.1')}`), \
			source_title:_.get(x,`versions.0.${env('field.0')}`)\
		}))

path = parents
value = get('parents')\
        .sortBy(['profondeur'])\
		.reverse()\
		.map(x =>({\
		     id: x.uri, \
			 value:_.get(x,`versions.0.${env('field.1')}`), \
			 target: x.uri, \
			 target_title:_.get(x,`versions.0.${env('field.1')}`), \
			 source_title:_.get(x,`versions.0.${env('field.0')}`), \
		}))

[exchange]
value = get('courant')\
			.concat(self.enfants)\
			.concat(self.parents)\
			.map((current, index, colllection) => ({\
				source: _.get(_.find(colllection, { value: current.source_title }), 'id'), \
				target: _.get(_.find(colllection, { value: current.target_title }), 'id'), \
				...current \
			}))
[ungroup]

[replace]
path = id
value = get('id')
path = value
value = self()

[aggregate]
path = id

; Soit le nombre de noeud trouvé en double dans les parcours montant et descandant
[assign]
path = value.0.weight
value = get('value').size()

[replace]
path = source
value = get('value').first().get('source')

path = target
value = get('value').first().get('target')

path = weight
value = get('value').first().get('weight')

path = total
value = env('total')

path = maxSize
value = env('maxSize')

path = minValue
value = env('minValue')

path = maxValue
value = env('maxValue')

[remove]
test = get('source').isUndefined()


[injectSyndicationFrom]
connectionStringURI = env('connectionStringURI')
path = source

[injectSyndicationFrom]
connectionStringURI = env('connectionStringURI')
path = target

# On génére le json de sortie
[LodexOutput]
indent = true
extract = total
extract = maxSize
extract = maxValue
extract = minValue
