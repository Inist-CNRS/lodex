; For a document selected by a URI (otherwise the first one in the stream), and with two fields as parameters, we build a hierarchy with a parent link between the two fields.
; Exemple d'URL http://localhost:3000/api/run/hierarchy-by/0yck/OEOA
; Exemple d'URL http://localhost:3000/api/run/hierarchy-by/0yck/OEOA?uri=uid:/nGrpMScfa

prepend = delegate?file=../worker.ini
mimeType = application/json
label = hierarchy

[use]
plugin = basics
plugin = lodex
plugin = analytics

[env]
path = connectionStringURI
value = get('connectionStringURI')

[buildContext]
connectionStringURI = env('connectionStringURI')

[env]
path = view
value = env('view').thru(x => (x === 'label' ? 'label' : 'uri'))

; On garde dans l'environnement quelques paramètres
path = minValue
value = env('minValue').split('§').map(parseFloat).shift().defaultTo(0)

path = maxValue
value = env('maxValue').split('§').map(parseFloat).shift().defaultTo(1)

path = maxSize
value = env('maxSize').parseInt().defaultTo(10)

path = reverse
value = env('orderBy').split('/').get(1).replace('asc', 0).replace('desc', 1).parseInt()

path = uri
value = get('filter.uri')

path = field
value = get('field').castArray()

; On récupére les documents filtrés
; Field.0 => identifiant du champ contenant la référence au parent, c'est-à-dire l'identifiant de la ressource liée hiérarchiquement
; Field.1 => identifiant du champ contenant l'identifiant de la ressource
[LodexAggregateQuery]
stage = fix('$unwind: "$versions"')
stage = fix(`$graphLookup: { from: "publishedDataset", startWith: "$versions.${env('field.0')}", connectFromField: "versions.${env('field.0')}", connectToField: "versions.${env('field.1')}", as: "parents", depthField: "profondeur" }`)
stage = fix(`$lookup: { from: "publishedDataset", localField: "versions.${env('field.1')}", foreignField: "versions.${env('field.0')}", as: "enfants" }`)

[assign]
path = id
value = get(`versions.${env('field.1')}`)

[replace]
path = id
value = get('id')

path = value
value = get('enfants').map(x =>[{uri:self.uri, label:self.id},{uri:x.uri, label:_.get(x,`versions.0.${env('field.1')}`)}])

path = parentsA
value = get('parents').sortBy(['profondeur']).reverse().map(x =>({uri: x.uri, label:_.get(x,`versions.0.${env('field.1')}`)}))

path = parentsB
value = get('parents').sortBy(['profondeur']).reverse().map(x =>({uri: x.uri, label:_.get(x,`versions.0.${env('field.1')}`)})).slice(1).concat({uri: self.uri, label:self.id})

[exchange]
value = get('parentsA').zip(self.parentsB).concat(self.value).filter(y => (y[0] && y[1])).filter(y => (y[0].label && y[1].label && y[0].label !== y[1].label)).map((x) => ({value:[x[0],x[1]], id: `${x[0].label}-${x[1].label}`}))

[ungroup]

[aggregate]
path = id

[replace]
path = source
value = get(`value.0.0.${env('view')}`)

path = target
value = get(`value.0.1.${env('view')}`)

# Doit thériquement correspondre aux nombres de documents dans la hiérachie, (sauf pour le noeud de tete qui n'ai pas pris en compte)
path = weight
value = get('value').size().subtract(1)

path = total
value = env('total')

path = maxSize
value = env('maxSize')

path = minValue
value = env('minValue')

path = maxValue
value = env('maxValue')

[injectSyndicationFrom]
connectionStringURI = env('connectionStringURI')
path = source

[injectSyndicationFrom]
connectionStringURI = env('connectionStringURI')
path = target

# On génére le json de sortie
[LodexOutput]
indent = true
extract = total
extract = maxSize
extract = maxValue
extract = minValue
